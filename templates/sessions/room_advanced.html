{% extends 'base.html' %}

{% block title %}Session Room - {{ session.title }} - PeerLearn{% endblock %}

{% block extra_head %}
<style>
    .video-container {
        position: relative;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 1rem;
        overflow: hidden;
    }
    .video-grid {
        display: grid;
        gap: 1rem;
        height: 100%;
    }
    .video-grid.single { grid-template-columns: 1fr; }
    .video-grid.two { grid-template-columns: 1fr 1fr; }
    .video-grid.three { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
    .video-grid.four { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
    .video-grid.many { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    
    .participant-video {
        background: #1a1a1a;
        border-radius: 0.75rem;
        position: relative;
        overflow: hidden;
    }
    
    .participant-video video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .participant-overlay {
        position: absolute;
        bottom: 0.5rem;
        left: 0.5rem;
        right: 0.5rem;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .chat-container {
        background: white;
        border-radius: 1rem;
        border: 1px solid #e5e7eb;
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    
    .connection-status {
        position: absolute;
        top: 1rem;
        right: 1rem;
        padding: 0.5rem 1rem;
        border-radius: 2rem;
        font-size: 0.875rem;
        font-weight: 600;
        z-index: 10;
    }
    
    .status-connecting { background: #fbbf24; color: #92400e; }
    .status-connected { background: #34d399; color: #065f46; }
    .status-disconnected { background: #f87171; color: #991b1b; }
    
    .controls-panel {
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 1rem;
        padding: 1rem;
    }
    
    .control-btn {
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        border: none;
        cursor: pointer;
    }
    
    .control-btn:hover {
        transform: scale(1.1);
    }
    
    .control-btn.active {
        background: #3b82f6;
        color: white;
    }
    
    .control-btn.inactive {
        background: #ef4444;
        color: white;
    }
    
    .control-btn.secondary {
        background: #6b7280;
        color: white;
    }
    
    .floating-controls {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        z-index: 50;
    }
    
    .screen-share-indicator {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: #3b82f6;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    @media (max-width: 768px) {
        .video-grid {
            grid-template-columns: 1fr !important;
            grid-template-rows: auto !important;
        }
        
        .chat-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50vh;
            border-radius: 1rem 1rem 0 0;
            transform: translateY(calc(100% - 3rem));
            transition: transform 0.3s ease;
            z-index: 40;
        }
        
        .chat-container.expanded {
            transform: translateY(0);
        }
        
        .floating-controls {
            bottom: 1rem;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen bg-gray-900" 
     x-data="sessionRoom()" 
     x-init="initRoom()"
     @beforeunload.window="leaveRoom()">
    
    <!-- Connection Status -->
    <div class="connection-status" 
         :class="`status-${connectionStatus}`">
        <span x-text="connectionStatusText"></span>
    </div>
    
    <!-- Session Info Header -->
    <div class="bg-white shadow-sm border-b border-gray-200 px-4 py-3">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
            <div>
                <h1 class="text-xl font-semibold text-gray-900">{{ session.title }}</h1>
                <p class="text-sm text-gray-600">with {{ session.mentor.get_full_name }}</p>
            </div>
            <div class="flex items-center space-x-4">
                <!-- Session Timer -->
                <div class="flex items-center space-x-2 text-sm text-gray-600">
                    <i data-feather="clock" class="h-4 w-4"></i>
                    <span x-text="sessionDuration"></span>
                </div>
                <!-- Participant Count -->
                <div class="flex items-center space-x-2 text-sm text-gray-600">
                    <i data-feather="users" class="h-4 w-4"></i>
                    <span x-text="`${Object.keys(participants).length + 1} participants`"></span>
                </div>
                <!-- Leave Button -->
                <button @click="leaveRoom()" 
                        class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors">
                    Leave
                </button>
            </div>
        </div>
    </div>
    
    <!-- Main Room Layout -->
    <div class="flex h-screen pt-16">
        <!-- Video Section -->
        <div class="flex-1 p-4 relative">
            <!-- Screen Share Indicator -->
            <div x-show="screenSharing" class="screen-share-indicator">
                <i data-feather="monitor" class="h-4 w-4"></i>
                <span>Screen Sharing Active</span>
            </div>
            
            <!-- Video Grid -->
            <div class="video-container h-full">
                <div class="video-grid p-4 h-full" 
                     :class="getVideoGridClass()">
                    
                    <!-- Local Video -->
                    <div class="participant-video">
                        <video id="localVideo" 
                               autoplay 
                               muted 
                               playsinline
                               :class="{ 'mirror': !screenSharing }"></video>
                        <div class="participant-overlay">
                            <div class="flex items-center space-x-2">
                                <span class="font-medium">You</span>
                                <span x-show="isMentor" class="bg-blue-500 text-white px-2 py-1 rounded text-xs">MENTOR</span>
                            </div>
                            <div class="flex items-center space-x-1">
                                <i :data-feather="audioEnabled ? 'mic' : 'mic-off'" 
                                   :class="audioEnabled ? 'text-green-400' : 'text-red-400'"
                                   class="h-4 w-4"></i>
                                <i :data-feather="videoEnabled ? 'video' : 'video-off'" 
                                   :class="videoEnabled ? 'text-green-400' : 'text-red-400'"
                                   class="h-4 w-4"></i>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Remote Videos -->
                    <template x-for="(participant, userId) in participants" :key="userId">
                        <div class="participant-video">
                            <video :id="`remoteVideo-${userId}`" 
                                   autoplay 
                                   playsinline></video>
                            <div class="participant-overlay">
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium" x-text="participant.username"></span>
                                    <span x-show="participant.is_mentor" 
                                          class="bg-blue-500 text-white px-2 py-1 rounded text-xs">MENTOR</span>
                                </div>
                                <div class="flex items-center space-x-1">
                                    <i :data-feather="participant.audioEnabled ? 'mic' : 'mic-off'" 
                                       :class="participant.audioEnabled ? 'text-green-400' : 'text-red-400'"
                                       class="h-4 w-4"></i>
                                    <i :data-feather="participant.videoEnabled ? 'video' : 'video-off'" 
                                       :class="participant.videoEnabled ? 'text-green-400' : 'text-red-400'"
                                       class="h-4 w-4"></i>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            
            <!-- Floating Controls -->
            <div class="floating-controls">
                <div class="controls-panel">
                    <div class="flex items-center space-x-4">
                        <!-- Audio Toggle -->
                        <button @click="toggleAudio()" 
                                :class="audioEnabled ? 'active' : 'inactive'"
                                class="control-btn">
                            <i :data-feather="audioEnabled ? 'mic' : 'mic-off'" class="h-5 w-5"></i>
                        </button>
                        
                        <!-- Video Toggle -->
                        <button @click="toggleVideo()" 
                                :class="videoEnabled ? 'active' : 'inactive'"
                                class="control-btn">
                            <i :data-feather="videoEnabled ? 'video' : 'video-off'" class="h-5 w-5"></i>
                        </button>
                        
                        <!-- Screen Share -->
                        <button @click="toggleScreenShare()" 
                                :class="screenSharing ? 'active' : 'secondary'"
                                class="control-btn">
                            <i data-feather="monitor" class="h-5 w-5"></i>
                        </button>
                        
                        <!-- Chat Toggle (Mobile) -->
                        <button @click="toggleChat()" 
                                class="control-btn secondary lg:hidden">
                            <i data-feather="message-circle" class="h-5 w-5"></i>
                        </button>
                        
                        <!-- Settings -->
                        <button @click="showSettings = true" 
                                class="control-btn secondary">
                            <i data-feather="settings" class="h-5 w-5"></i>
                        </button>
                        
                        <!-- End Session (Mentor Only) -->
                        <template x-if="isMentor">
                            <button @click="endSession()" 
                                    class="control-btn bg-red-600 text-white hover:bg-red-700">
                                <i data-feather="phone-off" class="h-5 w-5"></i>
                            </button>
                        </template>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Chat Sidebar -->
        <div class="w-80 hidden lg:block">
            <div class="chat-container h-full" :class="{ 'expanded': chatExpanded }">
                <!-- Chat Header -->
                <div class="p-4 border-b border-gray-200 bg-gray-50 rounded-t-lg">
                    <div class="flex items-center justify-between">
                        <h3 class="font-semibold text-gray-900">Session Chat</h3>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500" x-text="`${chatMessages.length} messages`"></span>
                            <button @click="chatExpanded = !chatExpanded" 
                                    class="lg:hidden text-gray-400 hover:text-gray-600">
                                <i data-feather="chevron-down" class="h-4 w-4"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Chat Messages -->
                <div class="flex-1 overflow-y-auto p-4 space-y-3" 
                     id="chatMessages"
                     x-ref="chatMessages">
                    <template x-for="message in chatMessages" :key="message.id">
                        <div class="flex items-start space-x-2"
                             :class="message.user_id === currentUserId ? 'flex-row-reverse space-x-reverse' : ''">
                            <!-- Avatar -->
                            <div class="w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-medium">
                                <span x-text="message.username.charAt(0).toUpperCase()"></span>
                            </div>
                            
                            <!-- Message -->
                            <div class="flex-1 max-w-xs">
                                <div :class="message.user_id === currentUserId ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-900'"
                                     class="p-3 rounded-lg">
                                    <p class="text-sm" x-text="message.message"></p>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-xs text-gray-500" x-text="message.username"></span>
                                    <span class="text-xs text-gray-400" x-text="formatTime(message.timestamp)"></span>
                                </div>
                            </div>
                        </div>
                    </template>
                    
                    <!-- System Messages -->
                    <template x-for="systemMessage in systemMessages" :key="systemMessage.id">
                        <div class="flex justify-center">
                            <span class="bg-gray-100 text-gray-600 px-3 py-1 rounded-full text-xs"
                                  x-text="systemMessage.message"></span>
                        </div>
                    </template>
                </div>
                
                <!-- Chat Input -->
                <div class="p-4 border-t border-gray-200 bg-gray-50 rounded-b-lg">
                    <form @submit.prevent="sendMessage()" class="flex space-x-2">
                        <input x-model="newMessage" 
                               type="text" 
                               placeholder="Type a message..." 
                               class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               maxlength="500">
                        <button type="submit" 
                                :disabled="!newMessage.trim()"
                                class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-feather="send" class="h-4 w-4"></i>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div x-show="showSettings" 
         x-cloak
         class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold">Session Settings</h3>
                <button @click="showSettings = false" class="text-gray-400 hover:text-gray-600">
                    <i data-feather="x" class="h-5 w-5"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <!-- Camera Selection -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Camera</label>
                    <select x-model="selectedCamera" 
                            @change="switchCamera()"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <template x-for="camera in availableCameras" :key="camera.deviceId">
                            <option :value="camera.deviceId" x-text="camera.label"></option>
                        </template>
                    </select>
                </div>
                
                <!-- Microphone Selection -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Microphone</label>
                    <select x-model="selectedMicrophone" 
                            @change="switchMicrophone()"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <template x-for="mic in availableMicrophones" :key="mic.deviceId">
                            <option :value="mic.deviceId" x-text="mic.label"></option>
                        </template>
                    </select>
                </div>
                
                <!-- Video Quality -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Video Quality</label>
                    <select x-model="videoQuality" 
                            @change="updateVideoQuality()"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <option value="low">Low (360p)</option>
                        <option value="medium">Medium (720p)</option>
                        <option value="high">High (1080p)</option>
                    </select>
                </div>
            </div>
            
            <div class="mt-6 flex justify-end space-x-3">
                <button @click="showSettings = false" 
                        class="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <!-- Connection Issues Modal -->
    <div x-show="showConnectionIssues" 
         x-cloak
         class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4">
            <div class="text-center">
                <div class="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i data-feather="wifi-off" class="h-8 w-8 text-red-600"></i>
                </div>
                <h3 class="text-lg font-semibold text-gray-900 mb-2">Connection Issues</h3>
                <p class="text-gray-600 mb-6">We're experiencing connectivity problems. We're trying to reconnect...</p>
                <div class="flex justify-center space-x-3">
                    <button @click="retryConnection()" 
                            class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                        Retry
                    </button>
                    <button @click="leaveRoom()" 
                            class="bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200">
                        Leave Session
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function sessionRoom() {
    return {
        // Session info
        sessionId: '{{ session.id }}',
        roomToken: '{{ room_token }}',
        isMentor: {{ user.is_mentor|yesno:"true,false" }},
        currentUserId: '{{ user.id }}',
        
        // Connection state
        localStream: null,
        remoteStreams: new Map(),
        peerConnections: new Map(),
        dataChannels: new Map(),
        socket: null,
        connectionStatus: 'connecting',
        
        // UI state
        participants: {},
        audioEnabled: true,
        videoEnabled: true,
        screenSharing: false,
        chatExpanded: false,
        showSettings: false,
        showConnectionIssues: false,
        
        // Chat
        chatMessages: [],
        systemMessages: [],
        newMessage: '',
        
        // Session
        sessionDuration: '00:00',
        sessionStartTime: null,
        
        // Device settings
        availableCameras: [],
        availableMicrophones: [],
        selectedCamera: '',
        selectedMicrophone: '',
        videoQuality: 'medium',
        
        // WebRTC Configuration
        rtcConfig: {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        },
        
        async initRoom() {
            try {
                console.log('Initializing WebRTC room...');
                
                // Get user media
                await this.getUserMedia();
                
                // Get available devices
                await this.getAvailableDevices();
                
                // Connect to WebSocket
                this.connectWebSocket();
                
                // Start session timer
                this.startSessionTimer();
                
                // Update icons
                this.updateIcons();
                
                console.log('WebRTC room initialized successfully');
            } catch (error) {
                console.error('Error initializing room:', error);
                this.handleError('Failed to initialize room: ' + error.message);
            }
        },
        
        async getUserMedia() {
            try {
                const constraints = this.getMediaConstraints();
                this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Display local video
                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.srcObject = this.localStream;
                }
                
                console.log('Got user media successfully');
            } catch (error) {
                console.error('Error getting user media:', error);
                throw new Error('Camera/microphone access denied. Please allow access and refresh the page.');
            }
        },
        
        getMediaConstraints() {
            const qualitySettings = {
                'low': { width: 640, height: 360, frameRate: 15 },
                'medium': { width: 1280, height: 720, frameRate: 24 },
                'high': { width: 1920, height: 1080, frameRate: 30 }
            };
            
            const quality = qualitySettings[this.videoQuality] || qualitySettings.medium;
            
            return {
                video: {
                    deviceId: this.selectedCamera ? { exact: this.selectedCamera } : undefined,
                    width: { ideal: quality.width },
                    height: { ideal: quality.height },
                    frameRate: { ideal: quality.frameRate }
                },
                audio: {
                    deviceId: this.selectedMicrophone ? { exact: this.selectedMicrophone } : undefined,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            };
        },
        
        async getAvailableDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                this.availableCameras = devices.filter(device => device.kind === 'videoinput');
                this.availableMicrophones = devices.filter(device => device.kind === 'audioinput');
                
                if (this.availableCameras.length > 0 && !this.selectedCamera) {
                    this.selectedCamera = this.availableCameras[0].deviceId;
                }
                
                if (this.availableMicrophones.length > 0 && !this.selectedMicrophone) {
                    this.selectedMicrophone = this.availableMicrophones[0].deviceId;
                }
            } catch (error) {
                console.error('Error getting devices:', error);
            }
        },
        
        connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/sessions/${this.sessionId}/`;
            
            this.socket = new WebSocket(wsUrl);
            
            this.socket.onopen = () => {
                console.log('WebSocket connected');
                this.connectionStatus = 'connected';
                
                // Send join message
                this.sendWebSocketMessage({
                    type: 'user_joined',
                    room_token: this.roomToken
                });
            };
            
            this.socket.onmessage = (event) => {
                this.handleWebSocketMessage(JSON.parse(event.data));
            };
            
            this.socket.onclose = (event) => {
                console.log('WebSocket disconnected:', event.code, event.reason);
                this.connectionStatus = 'disconnected';
                this.showConnectionIssues = true;
            };
            
            this.socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.connectionStatus = 'disconnected';
            };
        },
        
        async handleWebSocketMessage(data) {
            console.log('WebSocket message received:', data.type);
            
            try {
                switch (data.type) {
                    case 'user_joined':
                        await this.handleUserJoined(data);
                        break;
                    case 'user_left':
                        this.handleUserLeft(data);
                        break;
                    case 'webrtc_signal':
                        await this.handleWebRTCSignal(data);
                        break;
                    case 'chat_message':
                        this.handleChatMessage(data);
                        break;
                    case 'media_toggle':
                        this.handleMediaToggle(data);
                        break;
                    case 'session_ended':
                        this.handleSessionEnded(data);
                        break;
                }
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
            }
        },
        
        async handleUserJoined(data) {
            console.log('User joined:', data.username);
            
            // Add participant
            this.participants[data.user_id] = {
                username: data.username,
                is_mentor: data.is_mentor,
                audioEnabled: true,
                videoEnabled: true
            };
            
            // Add system message
            this.systemMessages.push({
                id: Date.now(),
                message: `${data.username} joined the session`
            });
            
            // Create peer connection
            await this.createPeerConnection(data.user_id);
            
            // Create offer if we're not the new user
            if (data.user_id !== this.currentUserId) {
                await this.createOffer(data.user_id);
            }
            
            this.updateIcons();
        },
        
        handleUserLeft(data) {
            console.log('User left:', data.username);
            
            // Remove participant
            delete this.participants[data.user_id];
            
            // Add system message
            this.systemMessages.push({
                id: Date.now(),
                message: `${data.username} left the session`
            });
            
            // Close peer connection
            if (this.peerConnections.has(data.user_id)) {
                this.peerConnections.get(data.user_id).close();
                this.peerConnections.delete(data.user_id);
            }
            
            // Remove remote video
            const remoteVideo = document.getElementById(`remoteVideo-${data.user_id}`);
            if (remoteVideo) {
                remoteVideo.srcObject = null;
            }
        },
        
        async handleWebRTCSignal(data) {
            const { signal_type, from_user } = data;
            
            console.log(`Received ${signal_type} from ${from_user}`);
            
            switch (signal_type) {
                case 'offer':
                    await this.handleOffer(data);
                    break;
                case 'answer':
                    await this.handleAnswer(data);
                    break;
                case 'ice_candidate':
                    await this.handleIceCandidate(data);
                    break;
            }
        },
        
        async createPeerConnection(userId) {
            const peerConnection = new RTCPeerConnection(this.rtcConfig);
            
            // Add local stream tracks
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, this.localStream);
                });
            }
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('Received remote track from:', userId);
                const [remoteStream] = event.streams;
                this.remoteStreams.set(userId, remoteStream);
                
                // Display remote video
                const remoteVideo = document.getElementById(`remoteVideo-${userId}`);
                if (remoteVideo) {
                    remoteVideo.srcObject = remoteStream;
                }
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    this.sendWebSocketMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate,
                        to_user: userId
                    });
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log(`Connection state with ${userId}:`, peerConnection.connectionState);
                
                if (peerConnection.connectionState === 'failed') {
                    console.log('Connection failed, attempting to restart ICE');
                    peerConnection.restartIce();
                }
            };
            
            // Create data channel
            const dataChannel = peerConnection.createDataChannel('chat', { ordered: true });
            
            dataChannel.onopen = () => {
                console.log('Data channel opened with:', userId);
                this.dataChannels.set(userId, dataChannel);
            };
            
            this.peerConnections.set(userId, peerConnection);
            return peerConnection;
        },
        
        async createOffer(userId) {
            const peerConnection = this.peerConnections.get(userId);
            if (!peerConnection) return;
            
            try {
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await peerConnection.setLocalDescription(offer);
                
                this.sendWebSocketMessage({
                    type: 'webrtc_offer',
                    offer: offer,
                    to_user: userId
                });
                
                console.log('Offer sent to:', userId);
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        },
        
        async handleOffer(data) {
            const { from_user, offer } = data;
            let peerConnection = this.peerConnections.get(from_user);
            
            if (!peerConnection) {
                peerConnection = await this.createPeerConnection(from_user);
            }
            
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                this.sendWebSocketMessage({
                    type: 'webrtc_answer',
                    answer: answer,
                    to_user: from_user
                });
                
                console.log('Answer sent to:', from_user);
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        },
        
        async handleAnswer(data) {
            const { from_user, answer } = data;
            const peerConnection = this.peerConnections.get(from_user);
            
            if (peerConnection) {
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    console.log('Answer processed from:', from_user);
                } catch (error) {
                    console.error('Error handling answer:', error);
                }
            }
        },
        
        async handleIceCandidate(data) {
            const { from_user, candidate } = data;
            const peerConnection = this.peerConnections.get(from_user);
            
            if (peerConnection) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log('ICE candidate added from:', from_user);
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
        },
        
        handleChatMessage(data) {
            this.chatMessages.push({
                id: Date.now(),
                username: data.username,
                message: data.message,
                timestamp: data.timestamp || Date.now(),
                user_id: data.user_id
            });
            
            // Auto-scroll to bottom
            this.$nextTick(() => {
                const chatContainer = this.$refs.chatMessages;
                if (chatContainer) {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            });
        },
        
        handleMediaToggle(data) {
            const participant = this.participants[data.user_id];
            if (participant) {
                if (data.media_type === 'audio') {
                    participant.audioEnabled = data.enabled;
                } else if (data.media_type === 'video') {
                    participant.videoEnabled = data.enabled;
                }
            }
        },
        
        handleSessionEnded(data) {
            // Show session ended message and redirect
            alert('Session has ended by the mentor.');
            window.location.href = `/sessions/${this.sessionId}/feedback/`;
        },
        
        sendWebSocketMessage(message) {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify(message));
            } else {
                console.warn('WebSocket not ready, message not sent:', message);
            }
        },
        
        sendMessage() {
            if (!this.newMessage.trim()) return;
            
            const message = {
                type: 'chat_message',
                message: this.newMessage.trim(),
                timestamp: Date.now()
            };
            
            this.sendWebSocketMessage(message);
            this.newMessage = '';
        },
        
        async toggleAudio() {
            if (this.localStream) {
                const audioTrack = this.localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    this.audioEnabled = audioTrack.enabled;
                    
                    // Notify other participants
                    this.sendWebSocketMessage({
                        type: 'media_toggle',
                        media_type: 'audio',
                        enabled: this.audioEnabled
                    });
                }
            }
        },
        
        async toggleVideo() {
            if (this.localStream) {
                const videoTrack = this.localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    this.videoEnabled = videoTrack.enabled;
                    
                    // Notify other participants
                    this.sendWebSocketMessage({
                        type: 'media_toggle',
                        media_type: 'video',
                        enabled: this.videoEnabled
                    });
                }
            }
        },
        
        async toggleScreenShare() {
            try {
                if (!this.screenSharing) {
                    // Start screen sharing
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });
                    
                    // Replace video track in all peer connections
                    const videoTrack = screenStream.getVideoTracks()[0];
                    
                    for (const [userId, peerConnection] of this.peerConnections) {
                        const sender = peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                    }
                    
                    // Update local video
                    const localVideo = document.getElementById('localVideo');
                    if (localVideo) {
                        localVideo.srcObject = screenStream;
                    }
                    
                    this.screenSharing = true;
                    
                    // Handle screen share end
                    videoTrack.onended = () => {
                        this.stopScreenShare();
                    };
                } else {
                    this.stopScreenShare();
                }
            } catch (error) {
                console.error('Error toggling screen share:', error);
            }
        },
        
        async stopScreenShare() {
            if (this.localStream) {
                const videoTrack = this.localStream.getVideoTracks()[0];
                
                // Replace screen share with camera in all peer connections
                for (const [userId, peerConnection] of this.peerConnections) {
                    const sender = peerConnection.getSenders().find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    
                    if (sender && videoTrack) {
                        await sender.replaceTrack(videoTrack);
                    }
                }
                
                // Update local video
                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.srcObject = this.localStream;
                }
            }
            
            this.screenSharing = false;
        },
        
        toggleChat() {
            this.chatExpanded = !this.chatExpanded;
        },
        
        async switchCamera() {
            try {
                const constraints = this.getMediaConstraints();
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Replace tracks
                const videoTrack = newStream.getVideoTracks()[0];
                const audioTrack = newStream.getAudioTracks()[0];
                
                // Update peer connections
                for (const [userId, peerConnection] of this.peerConnections) {
                    const videoSender = peerConnection.getSenders().find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    const audioSender = peerConnection.getSenders().find(s => 
                        s.track && s.track.kind === 'audio'
                    );
                    
                    if (videoSender && videoTrack) {
                        await videoSender.replaceTrack(videoTrack);
                    }
                    if (audioSender && audioTrack) {
                        await audioSender.replaceTrack(audioTrack);
                    }
                }
                
                // Stop old stream
                this.localStream.getTracks().forEach(track => track.stop());
                
                // Update local stream
                this.localStream = newStream;
                
                // Update local video
                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.srcObject = newStream;
                }
            } catch (error) {
                console.error('Error switching camera:', error);
            }
        },
        
        async switchMicrophone() {
            // Similar to switchCamera but for audio only
            this.switchCamera();
        },
        
        async updateVideoQuality() {
            this.switchCamera();
        },
        
        endSession() {
            if (confirm('Are you sure you want to end this session for all participants?')) {
                this.sendWebSocketMessage({
                    type: 'end_session'
                });
                
                // Redirect to feedback page
                window.location.href = `/sessions/${this.sessionId}/feedback/`;
            }
        },
        
        leaveRoom() {
            // Stop all tracks
            if (this.localStream) {
                this.localStream.getTracks().forEach(track => track.stop());
            }
            
            // Close all peer connections
            this.peerConnections.forEach(pc => pc.close());
            
            // Close WebSocket
            if (this.socket) {
                this.socket.close();
            }
            
            // Redirect
            window.location.href = '/dashboard/';
        },
        
        retryConnection() {
            this.showConnectionIssues = false;
            this.connectWebSocket();
        },
        
        startSessionTimer() {
            this.sessionStartTime = Date.now();
            
            setInterval(() => {
                const elapsed = Date.now() - this.sessionStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                this.sessionDuration = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        },
        
        getVideoGridClass() {
            const totalParticipants = Object.keys(this.participants).length + 1;
            
            if (totalParticipants === 1) return 'single';
            if (totalParticipants === 2) return 'two';
            if (totalParticipants <= 4) return 'four';
            return 'many';
        },
        
        formatTime(timestamp) {
            return new Date(timestamp).toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit'
            });
        },
        
        handleError(message) {
            console.error(message);
            alert(message);
        },
        
        updateIcons() {
            this.$nextTick(() => {
                if (typeof feather !== 'undefined') {
                    feather.replace();
                }
            });
        },
        
        get connectionStatusText() {
            const statusTexts = {
                'connecting': 'Connecting...',
                'connected': 'Connected',
                'disconnected': 'Disconnected'
            };
            return statusTexts[this.connectionStatus] || 'Unknown';
        }
    }
}
</script>
{% endblock %}